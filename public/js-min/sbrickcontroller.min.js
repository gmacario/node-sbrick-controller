/*global Backbone, keycode */
var SBrickChannel = Backbone.Model.extend(
    /** @lends SBrickChannel.prototype */
    {
        idAttribute: 'channelId',
        defaults: {
            channelId: null,
            min: -255,
            max: 255,
            keyInc: null,
            keyDec: null
        },
        /** @constructs */
        initialize: function () {

        },

        getKeyNames: function () {
            return {
                keyIncName: keycode(this.get('keyInc')),
                keyDecName: keycode(this.get('keyDec'))
            };
        }
    }
);

/** @class */
var SBrickChannelCollection = Backbone.Collection.extend(
    /** @lends SBrickChannelCollection.prototype */
    {
        model: SBrickChannel
    }
);
/*global Backbone, SBrickChannel, SBrickChannelCollection, TimeSeries, _ */
var SBrick = Backbone.Model.extend(
    /** @lends SBrick.prototype */
    {
        idAttribute: 'uuid',
        defaults: {
            uuid: null,
            swVersion: null,
            hwVersion: null,
            secured: false,
            connected: false,
            password: null,
            streamUrl: null
        },
        /** @constructs */
        initialize: function () {
            this.listenTo(this.channels, 'change', function () {
                this.save(); //save gets the channel object, we have to save the sbrick object
            });
            this.voltages = new TimeSeries();
            this.temperatures = new TimeSeries();
            this.set('connected', false);
        },

        toJSON: function (options) {
            var json = {
                uuid: this.get('uuid'),
                password: this.get('password'),
                streamUrl: this.get('streamUrl'),
                channels: this.channels.toJSON(options)
            };
            return json;
        },

        parse: function (resp, options) {
            if (this.channels === undefined) {
                this.channels = new SBrickChannelCollection();
                this.channels.add(new SBrickChannel({channelId: 0}));
                this.channels.add(new SBrickChannel({channelId: 1}));
                this.channels.add(new SBrickChannel({channelId: 2}));
                this.channels.add(new SBrickChannel({channelId: 3}));
            }

            if (resp.channels) {
                this.channels.reset(resp.channels);
            }

            return _.omit(resp, 'channels');
        },

        addVoltage: function (time, voltage) {
            this.voltages.append(time, voltage);
        },

        addTemperature: function (time, temperature) {
            this.temperatures.append(time, temperature);
        },

        connect: function () {
            if (!this.get('connected')) {
                this.trigger('connect', this);
            }
        },

        disconnect: function () {
            if (this.get('connected')) {
                this.trigger('disconnect', this);
            }
        },

        setConnected: function (connected) {
            this.set('connected', connected);
            if (connected === false){
                this.voltages.clear();
                this.temperatures.clear();
            }
        },

        getProxiedStreamUrl: function () {
            return '/sbricks/' + this.get('uuid') + '/video?rnd=' + Math.random();
        }
    }
);

/** @class */
var SBrickCollection = Backbone.Collection.extend(
    /** @lends SBrickCollection.prototype */
    {
        model: SBrick,
        url: '/sbricks'
    }
);

/*global Backbone, keycode, $, _ */
var SBrickChannelView = Backbone.View.extend({
    template: _.template($('#sbrick-channel-view').text()),

    events: {
        'change input[type=number]': 'updateModel',
        'keydown input[type=text]': 'setKey'
    },

    initialize: function () {
    },

    render: function () {
        this.setElement(this.template(_.merge(this.model.attributes, this.model.getKeyNames())));
        return this;
    },

    setKey: function (e) {
        e.preventDefault();
        var targetAttribute = $(e.target).hasClass('sbrick-control-panel-channel-keyinc') ? 'keyInc' : 'keyDec';
        this.model.set(targetAttribute, e.which);
        $(e.target).val(keycode(e.which)).blur();
    },

    updateModel: function () {
        this.model.set({
            'min': parseInt(this.$('.sbrick-control-panel-channel-minvalue').val(), 10),
            'max': parseInt(this.$('.sbrick-control-panel-channel-maxvalue').val(), 10)
        });
    },

    destroy: function () {
        this.remove();
    }
});

/*global Backbone, SBrickChannelView, SmoothieChart, $, _ */
var SBrickView = Backbone.View.extend({
    template: _.template($('#sbrick-view').text()),

    events: {
        'blur .sbrick-control-panel-password': 'updateModel',
        'blur .sbrick-control-panel-stream-url': 'updateModel',
        'click .sbrick-control-panel-connect': 'connect',
        'click .sbrick-control-panel-disconnect': 'disconnect'
    },

    initialize: function () {
        this.channelViews = [];
        this.timeline = null;
        this.listenTo(this.model, 'change:connected', this.initChart);
        this.listenTo(this.model, 'change:connected', this.setButtons);
        this.listenTo(this.model, 'change:streamUrl', this.setStream);
    },

    render: function () {
        this.setElement(this.template(this.model.attributes));

        var _this = this;

        this.model.channels.forEach(function (channel) {
            var channelView = new SBrickChannelView({model: channel});
            channelView.render().$el.appendTo(_this.$('.sbrick-control-panel-channels'));
            _this.channelViews.push(channelView);
        });

        if (this.model.get('secured') === false) {
            this.$('.sbrick-control-panel-passwords').hide();
        }

        this.setButtons();
        this.setStream();

        return this;
    },

    initChart: function () {
        if (this.timeline === null) {
            this.resizeCanvas();
            this.timeline = new SmoothieChart({minValue:0, millisPerPixel:25});

            this.timeline.addTimeSeries(this.model.voltages, {
                strokeStyle: 'rgba(0, 255, 0, 1)',
                fillStyle: 'rgba(0, 255, 0, 0.2)',
                lineWidth: 1
            });

            this.timeline.addTimeSeries(this.model.temperatures, {
                strokeStyle: 'rgba(255, 0, 0, 1)',
                fillStyle: 'rgba(255, 0, 0, 0.2)',
                lineWidth: 1
            });

            this.timeline.streamTo(this.$('.sbrick-control-panel-chart')[0]);
        } else {
            if (this.model.get('connected')) {
                this.timeline.start();
            } else {
                this.timeline.stop();
            }
        }
    },

    setButtons: function () {
        if (this.model.get('connected')) {
            this.$('.sbrick-control-panel-connect').addClass('pure-button-disabled');
            this.$('.sbrick-control-panel-disconnect').removeClass('pure-button-disabled');
        } else {
            this.$('.sbrick-control-panel-connect').removeClass('pure-button-disabled');
            this.$('.sbrick-control-panel-disconnect').addClass('pure-button-disabled');
        }
    },

    setStream: function () {
        if (this.model.get('streamUrl')) {
            this.$('.sbrick-control-panel-stream').attr('src', this.model.getProxiedStreamUrl()).show();
        } else {
            this.$('.sbrick-control-panel-stream').hide();
        }
    },

    resizeCanvas: function () {
        this.$('.sbrick-control-panel-chart')[0].width = this.$el.width();
    },

    updateModel: function () {
        this.model.set('password', this.$('.sbrick-control-panel-password').val());
        this.model.set('streamUrl', this.$('.sbrick-control-panel-stream-url').val());
        this.model.save();
    },

    connect: function () {
        this.model.connect();
    },

    disconnect: function () {
        this.model.disconnect();
    },

    destroy: function () {
        this.channelViews.forEach(function (channelView) {
            channelView.destroy();
        });

        this.remove();
    }
});

/*global Backbone, SBrickCollection, SBrickView, Socket */
var SBrickControllerView = Backbone.View.extend({
    events: {
        'keydown': 'keydown',
        'keyup': 'keyup',
        'click #sbrick-list-scan': 'scan'
    },

    initialize: function () {
        this.views = [];
        this.model = new SBrickCollection();

        this.listenTo(this.model, 'add', this.addSBrickView);
        this.listenTo(this.model, 'remove', this.removeSBrickView);
        this.listenTo(this.model, 'connect', this.connect);
        this.listenTo(this.model, 'disconnect', this.disconnect);
    },

    addSBrickView: function (sbrick) {
        var sbrickView = new SBrickView({model: sbrick});
        sbrickView.render().$el.appendTo(this.$('#sbricks'));
        this.views.push(sbrickView);
    },

    removeSBrickView: function (sbrick) {
        this.views.reduceRight(function (acc, view, index, object) {
            if (view.model === sbrick) {
                view.destroy();
                object.splice(index, 1);
            }
        }, []);
    },

    keydown: function (event) {
        var keycode = event.which;

        this.model.where({connected: true}).forEach(function (sbrick) {
            sbrick.channels.forEach(function (channel) {
                if (channel.get('keyDec') === keycode) {
                    Socket.controlChannel(sbrick.get('uuid'), channel.get('channelId'), channel.get('min'));
                }

                if (channel.get('keyInc') === keycode) {
                    Socket.controlChannel(sbrick.get('uuid'), channel.get('channelId'), channel.get('max'));
                }
            });
        });
    },

    keyup: function (event) {
        var keycode = event.which;

        this.model.where({connected: true}).forEach(function (sbrick) {
            sbrick.channels.forEach(function (channel) {
                if (channel.get('keyDec') === keycode || channel.get('keyInc') === keycode) {
                    Socket.controlChannel(sbrick.get('uuid'), channel.get('channelId'), 0);
                }
            });
        });
    },

    scan: function () {
        if (!this.model.some({connected: true}) || confirm('Warning: this will disconnect everything!')) {
            this.$('#sbrick-list-scan').attr('disabled', 'disabled');
            Socket.scan();
        }
    },

    scanResponse: function (sbricks) {
        this.$('#sbrick-list-scan').removeAttr('disabled');
        this.model.set(sbricks, {parse: true});
    },

    error: function (uuid, err) {
        console.log('error', uuid, err);
    },

    connect: function (sbrick) {
        var uuid = sbrick.get('uuid');
        Socket.connect(uuid, sbrick.get('password'));
    },

    connected: function (uuid) {
        this.model.get(uuid).setConnected(true);
    },

    disconnect: function (sbrick) {
        var uuid = sbrick.get('uuid');
        Socket.disconnect(uuid);
    },

    disconnected: function (uuid) {
        this.model.get(uuid).setConnected(false);
    },

    voltage: function (uuid, voltage) {
        this.model.get(uuid).addVoltage(Date.now(), voltage);
    },

    temperature: function (uuid, temperature) {
        this.model.get(uuid).addTemperature(Date.now(), temperature);
    },

    disconnectedFromServer: function () {
        this.model.set([]);
    }
});

/*global io, app */
var Socket = {
    initialize: function () {
        this.socket = io.connect(document.location.href);

        this.socket.on('SBrick.scanResponse', this.scanResponse);
        this.socket.on('SBrick.connected', this.connected);
        this.socket.on('SBrick.disconnected', this.disconnected);
        this.socket.on('SBrick.error', this.error);
        this.socket.on('SBrick.voltAndTemp', this.voltAndTemp);
        this.socket.on('SBrick.voltage', this.voltage);
        this.socket.on('SBrick.temperature', this.temperature);
        this.socket.on('connect', this.scan.bind(this));
        this.socket.on('disconnect', this.disconnectedFromServer);
        this.socket.on('log', this.log);
    },

    scan: function () {
        this.socket.emit('SBrick.scan');
    },

    scanResponse: function (sbricks) {
        app.scanResponse(sbricks);
    },

    connect: function (uuid, password) {
        this.socket.emit('SBrick.connect', uuid, password);
    },

    connected: function (uuid) {
        app.connected(uuid);
    },

    disconnect: function (uuid) {
        this.socket.emit('SBrick.disconnect', uuid);
    },

    disconnected: function (uuid) {
        app.disconnected(uuid);
    },

    controlChannel: function (uuid, channelId, pwd) {
        this.socket.emit('SBrick.controlChannel', uuid, channelId, pwd);
    },

    error: function (uuid, err) {
        app.error(uuid, err);
    },

    voltAndTemp: function (uuid, voltage, temperature) {
        app.voltage(uuid, voltage);
        app.temperature(uuid, temperature);
    },

    voltage: function (uuid, voltage) {
        app.voltage(uuid, voltage);
    },

    temperature: function (uuid, temperature) {
        app.temperature(uuid, temperature);
    },

    disconnectedFromServer: function () {
        app.disconnectedFromServer();
    },

    log: function (level, message) {
        console.log(level, message);
    }
};
var app = new SBrickControllerView({
    el: $('body')
});

Socket.initialize();