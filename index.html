<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
    <meta charset="UTF-8">
    <title>SBrick controller</title>
</head>
<body>
<input type="text" id="uuid" placeholder="uuid"><br>
<button id="connect">connect to your SBrick</button><br>
Use the arrow keys to control your creation.

<script src="/socket.io/socket.io.js"></script>
<script>
    var SBrickChannelSettings = function (channelId) {
        this.channelId = channelId;
        this.min = -255;
        this.max = 255;
        this.keyInc = null;
        this.keyDec = null;
    };

    var SBrickSettings = function (uuid) {
        this.uuid = uuid;
        this.channelSettings = [
            new SBrickChannelSettings(0),
            new SBrickChannelSettings(1),
            new SBrickChannelSettings(2),
            new SBrickChannelSettings(3)
        ]
    };

    var socket = io.connect('http://localhost:8000');
    var sbricks = [];

    socket.emit('SBrick.scan');
    socket.on('SBrick.scanResults', (uuids) => {
        console.log(uuids);
        document.getElementById('uuid').value = uuids[0];
    });

    socket.on('SBrick.error', (uuid, err) => {
        console.log('error', uuid, err);
    });

    socket.on('SBrick.ready', (uuid) => {
        sbricks.push(new SBrickSettings(uuid));
    });



    document.getElementById('connect').onclick = function () {
        this.remove();
        var uuid = document.getElementById('uuid').value;

        socket.emit('SBrick.connect', uuid);

        document.onkeydown = function (event) {
            event = event || window.event;

            var e = event.keyCode;

            sbricks.forEach((sbrick) => {
                sbrick.channelSettings.forEach((channel) => {
                    if (channel.keyDec === e) {
                        socket.emit('SBrick.controlChannel', sbrick.uuid, channel.channelId, channel.min);
                    }

                    if (channel.keyInc === e) {
                        socket.emit('SBrick.controlChannel', sbrick.uuid, channel.channelId, channel.max);
                    }
                });
            });

            //up
            if (e === 38) {
                socket.emit('SBrick.controlChannel', uuid, 1, 255);
            }

            //down
            if (e === 40) {
                socket.emit('SBrick.controlChannel', uuid, 1, -255);
            }

            //left
            if (e === 37) {
                socket.emit('SBrick.controlChannel', uuid, 2, 255);
            }

            //right
            if (e === 39) {
                socket.emit('SBrick.controlChannel', uuid, 2, -255);
            }
        };

        document.onkeyup = function (event) {
            event = event || window.event;

            var e = event.keyCode;

            sbricks.forEach((sbrick) => {
                sbrick.channelSettings.forEach((channel) => {
                    if (channel.keyDec === e || channel.keyInc === e) {
                        socket.emit('SBrick.controlChannel', sbrick.uuid, channel.channelId, 0);
                    }
                });
            });

            //up
            if (e === 38) {
                socket.emit('SBrick.controlChannel', uuid, 1, 0);
            }

            //down
            if (e === 40) {
                socket.emit('SBrick.controlChannel', uuid, 1, 0);
            }

            //left
            if (e === 37) {
                socket.emit('SBrick.controlChannel', uuid, 2, 0);
            }

            //right
            if (e === 39) {
                socket.emit('SBrick.controlChannel', uuid, 2, 0);
            }
        };
    }

</script>
</body>
</html>